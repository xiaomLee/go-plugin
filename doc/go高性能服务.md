## Go高性能服务

### 内存优化

1. 工具

   pprof、trace

2. 逃逸分析
   
   请记住这个： 栈分配廉价，堆分配昂贵
   
   编译命令 go build -gcflags '-m' 会让编译器在编译时输出逃逸分析的结果。
   
   能引起变量逃逸到堆上的典型情况：
   
   发送指针或带有指针的值到 channel 中。在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
   
   在一个切片上存储指针或带指针的值。一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
   
   slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
   
   在 interface 类型上调用方法。在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。
   
   以我们的经验，这四点是 Go 程序中最常见的导致堆分配的原因。幸运的是，是有解决办法的！下面我们深入几个具体例子说明，如何定位线上系统的内存性能问题。
   
3. 关于指针

   一个经验是： 指针指向的数据都是在堆上分配的。 因此，在程序中减少指针的运用可以减少堆分配。这不是绝对的，但是我们发现这是在实际问题中最常见的问题。
   
   一般情况下我们会这样认为： “值的拷贝是昂贵的，所以用一个指针来代替。”
   
4. 传递 Slice

   切片是造成低效内存分配行为的狂热区域。除非切片的大小在编译时就能知道，否则切片背后的数组(map也一样)会在堆上分配。
   
5. 小贴士
    
   不要过早优化，用数据来驱动我们的优化工作。
   
   栈空间分配是廉价的，堆空间分配是昂贵的。
   
   了解逃逸机制可以让我们写出更高效的代码。
   
   指针的使用会导致栈分配更不可行。
   
   找到在低效代码块中提供分配控制的 api。
   
   在调用频繁的地方慎用 interface。
   
6. 参考

   [逃逸分析](https://www.ctolib.com/topics-139052.html)
   
   [pprof](https://blog.golang.org/pprof)
   
   [工具](https://www.ctolib.com/topics-141214.html)